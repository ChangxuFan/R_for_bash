#!/opt/apps/R/3.6.1/bin/Rscript
suppressMessages(library(dplyr))
suppressMessages(library(jsonlite))
suppressMessages(library("argparse"))
options(stringsAsFactors = F)
debug <- F

help.text <- 
  "
  This script puts AIAP results (aka, the target ATAC pipeline) onto https://qa.targetepigenomics.org/ for visualization
  It depends on R packages dplyr, jsonlite and argparse (on version R/3.6.1)
  usage: 
  qatac_public.R [-h] [-f] -i your.tsv
  -h (--h): print help
  -f (--force): force. when specified, overwrite existing collections
  -i (--input): 
  takes in a tab separated file with 3 columns: collection; pipedir; samples. 
  example: /bar/cfan/4dn/nk/crispr/2022-09-14_atac/sth/target_pipe/qatacViewer.tsv
   
  collection	pipedir	samples
  KO_M2	/bar/cfan//4dn/nk/crispr/2022-09-14_atac/sth/target_pipe	ctrl_Hneg
  KO_M2	/bar/cfan//4dn/nk/crispr/2022-09-14_atac/sth/target_pipe	ctrl_Hpos
  KO_M2	/bar/cfan//4dn/nk/crispr/2022-09-14_atac/sth/target_pipe	KO1_Hneg
  KO_M2	/bar/cfan//4dn/nk/crispr/2022-09-14_atac/sth/target_pipe	KO2_Hneg
   
  if you are not sure, take a look inside /bar/cfan//4dn/nk/crispr/2022-09-14_atac/sth/target_pipe
  For samples: you don't have to write the full name of the directories generated by the target pipe,
  as long as you put in a unique identifier.
  This tsv file generated the KO_M2 collection (click 'datasource') on https://qa.targetepigenomics.org/
  
  mechanism of action:
  This script adds your collections onto the shared json file /bar/dli/public_html/qATACviewer/data.json,
  at the same time it will make a copy of the previous file in the directory /bar/qATAC_bk/ with a timestamp
  
  "

parser <- argparse::ArgumentParser(add_help = F)
parser$add_argument("-i", "--input", required = F, default = NULL)
parser$add_argument("-f", "--force", required = F, action = "store_true")
parser$add_argument("-h", "--help", required = F, action = "store_true")
args <- parser$parse_args()

if (args$help) {
  cat(help.text)
  stop()
}

if (is.null(args$input)) {
  cat(help.text)
  stop()
}

if (!file.exists(args$input)) {
  stop(paste0("input file not found: ", args$input, "\nhelp:\n", help.text))
}
add.to <- "/bar/dli/public_html/qATACviewer/data.json"


qatacview.jsongen <- function(tsv, add.to, out.json=NULL, replace=F, force = F) {
  # check input
  if (!file.exists(add.to)) {
    stop(paste0(add.to, " does not exist"))
  }
  
  df <- suppressWarnings(read.table(tsv, header = T, as.is = T, sep="\t"))
  fields <- c("collection", "pipedir", "samples")
  not_found <- fields[!fields %in% colnames(df)]
  if (length(not_found) > 0) {
    stop(paste0("required columns(s) not found: ", paste0(not_found, collapse = ", "), "\n"))
  }
  
  if (nrow(df) < 1) {
    stop("input file has zero rows")
  }
  
  collections <- df$collection %>% unique()
  collection.dirs <- paste0("~/public_html/qATAC/", collections)
  found <- collections[dir.exists(collection.dirs)]
  if (length(found) > 0) {
    if (force) {
      print("removing existing collection(s) under ~/public_html/qATAC/")
      system(paste0("rm -rf ", collection.dirs))
    } else {
      stop(paste0("collection(s) already exists under ~/public_html/qATAC/:\n",
                  paste0(found, collapse = ", "), 
                  "\nplease remove them first or use -f to overwrite\n"))
    }
  }
  
  split(df, f = factor(df$collection, levels = df$collection %>% unique())) %>%
    lapply(function(in.df.co) {
      dups <- in.df.co$samples %>% .[duplicated(.)]
      if (length(dups) > 0) {
        stop(paste0("the following samples are duplicated for collection '",
                    in.df.co$collection, "': ", paste0(dups, collapse = ", ")))
      }
    })
  
  jsongen <- list()
  
  jsongen[["allOptions"]] <- lapply(collections, function(x) {
    return(list(value = x, label = x, clearableValue=F))
  })
  jsongen[["allProducts"]] <- split(df, f = factor(df$collection, levels = df$collection %>% unique())) %>%
    lapply(function(in.df.co) {
      json.df.co <- in.df.co %>% split(., f = 1:nrow(.)) %>% 
        lapply(function(in.df.sample) {
          # not checking rows because it's impossible to have not exactly 1
          globs <- paste0(in.df.sample$pipedir, "/*", in.df.sample$samples, "*/", 
                          c("step3.2_normalized_per_10M*.bigWig", "QC*json"))
          glob.names <- c("normalized bigwig file", "QC json file")
          files <- sapply(1:2, function(i) {
            glob <- globs[i]
            glob.name <- glob.names[i]
            file <- Sys.glob(glob)
            if (length(file) < 1) {
              print(paste0(glob.name, " not found for this record:\n"))
              print(in.df.sample)
              stop(paste0("glob returned nothing: ", glob))
            } else if (length(file) > 1) {
              print(paste0("multiple ", glob.name, " was found for this record:\n"))
              print(in.df.sample)
              stop(paste0("glob returned multiple matches: ", glob))
            }
            return(file)
          })
          
          # now we create softlinks:
          collection.dir <- paste0("~/public_html/qATAC/", in.df.sample$collection)
          dir.create(collection.dir, showWarnings = F, recursive = T)
          dest <- paste0(collection.dir, "/", in.df.sample$samples)
          user <- Sys.info()[["user"]]
          http <- sub("~/public_html/", paste0("https://wangftp.wustl.edu/~", user, "/"), dest)
          if (file.exists(dest)) {
            if (force) {
              system(paste0("rm -rf ", dest))
              print(paste0("overwriting directory: ", dest))
            } else {
              stop(paste0(dest, " already exists. use -f to overwrite"))
            }
          }
          
          links <- sapply(files, function(file) {
            dir.create(dest, recursive = T, showWarnings = F)
            system(paste0("ln -s ", normalizePath(file), " ", dest, "/"))
            url <- paste0(http, "/", basename(file))
            return(url)
          })
          res <- data.frame(sample = in.df.sample$samples, url = links[1], assay = "ATAC-seq", file = links[2])
          return(res)
        }) %>% Reduce(rbind, .)
      json.df.co$id <- 1:nrow(json.df.co)
      
      return(json.df.co)
    })
  
  timestamp <- Sys.time() %>% as.character() %>% sub(" +", "_", .)
  bk.dir <- paste0("/bar/qATAC_bk")
  if (!dir.exists(bk.dir)) {
    dir.create(bk.dir)
    system(paste0("chmod 777 ", bk.dir))
  }
  bk <- paste0(bk.dir, "/data.json.bk.", timestamp)
  system(paste0("cp ", add.to, " ", bk))
  
  json.out <- jsonlite::read_json(path = add.to)
  jsongen$allProducts <- lapply(jsongen$allProducts, function(df) {
    res <- df %>% split(f = 1:nrow(df)) %>% lapply(as.list) %>% 
      `names<-`(NULL)
    return(res)
  })
  
  found <- names(json.out$allProducts)
  o <- intersect(found, names(jsongen$allProducts))
  if (length(o) > 0) {
    if (force) {
      print(paste0("overwriting existing collections in json file ", add.to, ": ", 
                   paste0(o, collapse = ", ")))
      json.out$allProducts <- json.out$allProducts %>% .[!names(.) %in% o]
      json.out$allOptions <- json.out$allOptions %>% .[!sapply(., function(x) return(x$value %in% o))]
    } else {
      stop(paste0("the following collections already exists in json file ", add.to, ": ",
                  paste0(o, collapse = ", ")))
    }
  }
  json.out$allOptions <- c(jsongen$allOptions, json.out$allOptions)
  json.out$allProducts <- c(jsongen$allProducts, json.out$allProducts)
  json <- json.out %>% jsonlite::toJSON(auto_unbox = T) %>% jsonlite::prettify()
  if (replace == T)
    write(json, add.to)
  if (!is.null(out.json))
    write(json, out.json)

  invisible(jsongen)
}

if (debug == T) {
  qatacview.jsongen(tsv = args$input, add.to = add.to, replace = F,
                    force = args$force, out.json = "debug.json")
} else {
  qatacview.jsongen(tsv = args$input, add.to = add.to, replace = T, force = args$force)
}

